/**
 * OpenLayers Map Module
 * This module will initialize map from the given parameter
 *
 * @author			Aby Dahana
 * @profile			abydahana.github.io
 *
 * Property of Aksara Laboratory
 * www.aksaracms.com
 */

"use strict";

/**
 * default variables
 */
var _this,
	xhr,
	map,
	layerVector,
	layerOverlap,
	clickedPoint,
	measurementVector,
	routeWayPoints,
	routeLineString,
	selected,
	selectionBox,
	drawingManager,
	drawingType,
	draggableMarker,
	lngLat,
	colorscheme,
	fill_color,
	stroke_color,
	stroke_width,
	icon_pattern,
	icon_scale,
	geocoder,
	geolocation,
	apply_coordinate,
	apply_latitude,
	apply_longitude,
	apply_address,
	apply_measurement,
	apply_route_from,
	apply_route_to,
	source_url,
	rest_url,
	wms_url,
	geojson,
	clicked,
	highlighted,
	previousCenter									= [],
	maxZoom											= 20,
	features										= [],
	projection										= 'EPSG:4326',
	popup											= new ol.Overlay.Popup(),
	highlight										= new ol.interaction.Select(),
	tileSource										= new ol.source.XYZ
	({
		/* Google Maps will be used, comment the url and attributions to rollback the default */
		url: (config.default_map_tile ? config.default_map_tile : 'https://mt{0-3}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}'),
		attributions:
		[
			'Â© <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.'
		],
		crossOrigin: 'anonymous'
	});

var openlayers										= (function()
{
	return {
		/**
		 * render the map
		 */
		render: function(_this_)
		{
			openlayers.reset();
			
			/* keep the "this" context */
			_this									= _this_,
			apply_coordinate						= _this.attr('data-apply-coordinate-to'),
			apply_latitude							= _this.attr('data-apply-latitude-to'),
			apply_longitude							= _this.attr('data-apply-longitude-to'),
			apply_address							= _this.attr('data-apply-address-to'),
			apply_measurement						= _this.attr('data-apply-measurement-to'),
			apply_route_from						= (_this.attr('data-route-from') ? JSON.parse(_this.attr('data-route-from')) : []),
			apply_route_from						= (typeof(apply_route_from.lat) !== 'undefined' && typeof(apply_route_from.lng) ? [apply_route_from.lat, apply_route_from.lng] : apply_route_from),
			apply_route_to							= (_this.attr('data-route-to') ? JSON.parse(_this.attr('data-route-to')) : []),
			apply_route_to							= (typeof(apply_route_to.lat) !== 'undefined' && typeof(apply_route_to.lng) ? [apply_route_to.lat, apply_route_to.lng] : apply_route_to),
			
			source_url								= _this.attr('data-source-url'),
			rest_url								= _this.attr('data-rest-url'),
			wms_url									= _this.attr('data-wms-url'),
			
			fill_color								= (_this.attr('data-fill') ? _this.attr('data-fill') : null),
			stroke_color							= (_this.attr('data-stroke') ? _this.attr('data-stroke') : null),
			stroke_width							= (_this.attr('data-stroke-width') ? _this.attr('data-stroke-width') : null),
			icon_pattern							= (_this.attr('data-icon') ? _this.attr('data-icon') : null),
			icon_scale								= (_this.attr('data-icon-scale') ? _this.attr('data-icon-scale') : null),
			
			leave_page								= false,
			
			/* set the coordinate from data-coordinate attribute*/
			lngLat									= (_this.attr('data-coordinate') ? JSON.parse(_this.attr('data-coordinate')) : (_this.attr('data-map-center') ? JSON.parse(_this.attr('data-map-center')) : [])),
			lngLat									= (lngLat && (typeof lngLat.lng !== 'undefined' && typeof lngLat.lat !== 'undefined' ? [lngLat.lng, lngLat.lat] : (typeof lngLat[0] !== 'undefined' && typeof lngLat[1] !== 'undefined' ? [lngLat[0], lngLat[1]] : [107.0825363, -6.2355892]))),
			colorscheme								= (typeof lngLat.colorscheme !== 'undefined' ? lngLat.colorscheme : '#ff0000');
			
			if(!_this.attr('id'))
			{
				_this.attr('id', 'maps')
			}
			
			if(map)
			{
				map.dispose()
			}
			
			/* define and render map */
			map										= new ol.Map
			({
				renderer: 'webgl',
				interactions: ol.interaction.defaults
				({
					mouseWheelZoom: false,
					dragPan: true
				})
				.extend
				([
					new ol.interaction.MouseWheelZoom
					({
						condition: function(e)
						{
							return (0 != _this.attr('data-mousewheel') || ol.events.condition.platformModifierKeyOnly(e));
						}
					})
				]),
				target: _this.attr('id'),
				layers:
				[
					new ol.layer.Tile
					({
						/*source: new ol.source.OSM()*/
						source: tileSource
					})
				],
				view: new ol.View
				({
					center: ol.proj.fromLonLat(lngLat),
					zoom: (_this.attr('data-zoom') ? parseInt(_this.attr('data-zoom')) : 12),
					maxZoom: maxZoom
				}),
				loadTilesWhileAnimating: false,
				loadTilesWhileInteracting: false
			});
			
			var resolution							= map.getView().getResolution();
			
			/* add fullscreen control */
			(_this.attr('control-fullscreen') && $(window).outerWidth() > 1024 ? map.addControl(new ol.control.FullScreen()) : ''),
			
			/* add scaleline control */
			(_this.attr('control-scaleline') ? map.addControl(new ol.control.ScaleLine()) : ''),
			
			/* add mouseposition control */
			(_this.attr('control-mouseposition') ? map.addControl(new ol.control.MousePosition({coordinateFormat: ol.coordinate.createStringXY(6), projection: projection, prefix: 'Degrees', undefinedHTML: '&nbsp;'})) : ''),
			
			/* add zoom extent control */
			(_this.attr('control-zoom-extent') ? map.addControl(new ol.control.ZoomToExtent({extent: map.getView().calculateExtent()})) : ''),
			
			$('.ol-zoom-extent').children('button').html('<i class="mdi mdi-home"></i>'),
			
			$('.ol-zoom-extent').on('click', function(){map.getView().fit(map.getView().calculateExtent(), {size: map.getSize()}), map.getView().setResolution(resolution)});
			
			if(_this.attr('data-drawing-manager'))
			{
				/* change map tiles to satellite */
				tileSource.setUrl((config.default_map_tile ? config.default_map_tile : 'https://mt{0-3}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}'))
			}
			else
			{
				/* add default popup */
				map.addOverlay(popup),
				
				/* add highlight interaction */
				map.addInteraction(highlight),
				
				/* add dot to clicked map */
				map.on('singleclick', function(event)
				{
					if(popup)
					{
						/* hide previous popup */
						popup.hide()
					}
					
					/**
					 * Add the pointer to the map
					 */
					if(clickedPoint && clickedPoint.getSource().getFeatures().length)
					{
						clickedPoint.getSource().getFeatures()[0].setGeometry(new ol.geom.Point(event.coordinate))
					}
					else
					{
						clickedPoint				= new ol.layer.VectorImage
						({
							source: new ol.source.Vector
							({
								features:
								[
									new ol.Feature
									({
										geometry: new ol.geom.Point(event.coordinate)
									})
								]
							}),
							style: new ol.style.Style
							({
								image: new ol.style.Circle
								({
									radius: 5,
									stroke: new ol.style.Stroke
									({
										color: '#880000',
										width: 1
									}),
									fill: new ol.style.Fill
									({
										color: '#ff0000'
									})
								})
							}),
							zIndex: 100,
							initial: 'clickedPoint'
						});
						
						map.addLayer(clickedPoint)
					}
					
					var selected					= highlight.getFeatures();
					
					if(clicked && _this.attr('data-finder-url')) return false;
					
					var coordinate					= ol.proj.transform(event.coordinate, map.getView().getProjection(), projection);
					
					var target						= map.forEachFeatureAtPixel(event.pixel, function(point, layer)
					{
						return {
							point: point,
							layer: layer
						};
					});
					
					if(typeof target !== 'undefined' && typeof target.point !== 'undefined')
					{
						selected.clear(),
						
						selected.push(target.point)
					}
					
					/**
					 * Open the popup to find the features on the clicked point
					 */
					popup.show(event.coordinate, ('<div class="popup-placeholder"><div class="popup-content"><div class="d-flex justify-content-center p-3"><div class="spinner-border spinner-border-sm" role="status"><span class="visually-hidden">' + (phrase.loading ? phrase.loading : 'Loading...') + '</span></div></div></div></div>'));
					
					if(_this.attr('data-finder-url'))
					{
						/**
						 * Request detail from AJAX
						 */
						$.ajax
						({
							url: _this.attr('data-finder-url'),
							method: 'POST',
							data:
							{
								objectID: (typeof target !== 'undefined' && typeof target.point !== 'undefined' ? target.point.get('object_id') : 0),
								coordinate: coordinate
							},
							beforeSend: function()
							{
								clicked				= true;
								
								$('.popup-content').closest('.ol-popup-content').removeAttr('style')
							}
						})
						.done(function(response)
						{
							clicked					= false;
							
							if(typeof response.content !== 'undefined' && response.content)
							{
								/**
								 * Data found from ajax response
								 */
								$('.popup-content, .identification-information').html(response.content);
								
								if(typeof response.width === 'number')
								{
									$('.popup-content').closest('.ol-popup-content').attr('style', 'width: ' + response.width + 'px!important')
								}
							}
							else if(typeof target !== 'undefined' && typeof target.point !== 'undefined' && typeof target.point.values_ !== 'undefined')
							{
								/**
								 * Show detail from available properties
								 */
								var content			= '';
								var num				= 0;
								
								$.each(target.point.values_, function(key, val)
								{
									if('geometry' === key) return;
									
									content			+= '<div class="row text-sm' + (num ? ' border-top' : '') + '"><div class="col-4 text-muted text-end pe-0">' + key + '</div><div class="col-8 text-break-word">' + val + '</div></div>';
									
									num++;
								}),
								
								$('.popup-content, .identification-information').addClass('p-3').html(content)
							}
							else
							{
								/**
								 * No data attribute found, close popup
								 */
								popup.hide()
							}
						})
					}
					else if(typeof target !== 'undefined' && typeof target.point !== 'undefined' && typeof target.point.values_ !== 'undefined')
					{
						/**
						 * Show detail from available properties
						 */
						var content					= '';
						var num						= 0;
						
						$.each(target.point.values_, function(key, val)
						{
							if('geometry' === key) return;
							
							content					+= '<div class="row text-sm' + (num ? ' border-top' : '') + '"><div class="col-4 text-muted text-end pe-0">' + key + '</div><div class="col-8 text-break-word">' + val + '</div></div>';
							
							num++;
						}),
						
						$('.popup-content, .identification-information').addClass('p-3').html(content)
					}
					else
					{
						/**
						 * No data attribute found, close popup
						 */
						popup.hide()
					}
					
					/**
					 * Start routing
					 */
					if(coordinate && $('.route-start').length && !$('.route-start').val())
					{
						/* add start point */
						$('.route-start').val(coordinate.reverse().join(), projection)
					}
					else if(coordinate && $('.route-end').length && !$('.route-end').val())
					{
						/* add destination point */
						$('.route-end').val(coordinate.reverse().join(), projection)
					}
				})
			}
			
			/* on property change */
			map.getView().on('propertychange', function(event)
			{
				if(typeof geolocation !== 'undefined')
				{
					/* stop tracking to prevent map flicker */
					geolocation.setTracking(false)
				}
			}),
			
			/* on pointermove */
			map.on('pointermove', function(event)
			{
				var pixel							= map.getEventPixel(event.originalEvent),
					hit								= map.hasFeatureAtPixel(pixel);
					
				map.getViewport().style.cursor		= hit ? 'pointer' : '';
			}),
			
			/* on drag end */
			map.on('moveend', function(event)
			{
				var selected						= highlight.getFeatures().getArray();
				
				if(_this.attr('data-clustering-url') && !selected.length)
				{
					/**
					 * Get the clustering features
					 */
					var coordinate					= ol.proj.transform(map.getView().getCenter(), map.getView().getProjection(), projection),
						latitude					= (typeof coordinate[1] !== 'undefined' ? coordinate[1] : 0),
						longitude					= (typeof coordinate[0] !== 'undefined' ? coordinate[0] : 0),
						distance					= 0,
						checked						= [];
					
					try
					{
						checked						= (sessionStorage.getItem('checked_layers') ? JSON.parse(sessionStorage.getItem('checked_layers')) : []);
					}
					catch(e)
					{
					}
					
					/* don't apply the clustering if there's any layer checked */
					if(checked.length) return;
					
					if(previousCenter.length)
					{
						/* get distance from previous center point */
						var line					= new ol.geom.LineString([previousCenter, map.getView().getCenter()]),
							distance				= Math.round(line.getLength() * event.map.getView().getResolution()) / event.map.getView().getResolution();
					}
					
					if(!previousCenter.length || distance > event.map.getView().getResolution())
					{
						xhr							= $.ajax
						({
							url: _this.attr('data-clustering-url'),
							method: 'POST',
							data:
							{
								lat: latitude,
								lng: longitude,
								keyword: _this.closest('form').find('input[name=keyword]').val(),
								marker: checked,
								distance: Math.round(distance / event.map.getView().getResolution())
							},
							beforeSend: function()
							{
								if(xhr)
								{
									xhr.abort()
								}
								
								_this.closest('form').find('button[type=submit]').find('.mdi').removeClass('mdi-magnify').addClass('mdi-loading mdi-spin')
							}
						})
						.done(function(response)
						{
							if(response)
							{
								openlayers.unzip(response, _this.closest('form').find('button[type=submit]').find('.mdi'), null, true)
							}
						})
						.fail(function()
						{
							_this.closest('form').find('button[type=submit]').find('.mdi').removeClass('mdi-loading mdi-spin').addClass('mdi-magnify')
						})
						
						previousCenter				= map.getView().getCenter();
					}
				}
			}),
			
			/* update map size */
			map.updateSize(),
			
			(_this.attr('data-coordinate') ? openlayers.coordinate((1 == _this.attr('data-draggable') ? true : false)) : null),
			
			(_this.attr('data-geocoder') ? openlayers.geocoder(_this) : null),
			
			(_this.attr('data-geolocation') ? openlayers.geolocation() : null),
			
			(wms_url ? openlayers.wms(wms_url) : null),
			
			(_this.attr('data-geojson') ? openlayers.geojsonString(JSON.parse(_this.attr('data-geojson')), _this.attr('data-drawing-type')) : null),
			
			(source_url ? openlayers.source(source_url) : null),
			
			(rest_url ? openlayers.rest(rest_url) : null);
			
			if($('.reverse_latitude').length && $('.reverse_longitude').length)
			{
				$('body').off('change.latLng keyup.latLng'),
				$('body').on('change.latLng keyup.latLng', '.reverse_latitude, .reverse_longitude', function(e)
				{
					var latitude					= $('.reverse_latitude').val(),
						longitude					= $('.reverse_longitude').val(),
						geojson						= new ol.format.GeoJSON();
						
					if(!isFinite(latitude) || !isFinite(longitude))
					{
						return;
					}
					
					if(Math.abs(latitude) > 90 || Math.abs(latitude) < -90)
					{
						latitude					= 0;
					}
					
					if(Math.abs(longitude) > 180 || Math.abs(longitude) < -180)
					{
						longitude					= 0;
					}
					
					if(latitude && longitude)
					{
						if(layerVector)
						{
							/* clear prevously drawn feature */
							layerVector.getSource().clear()
						}
						
						if(draggableMarker)
						{
							/* push layer to map */
							draggableMarker.getSource().getFeatures()[0].setGeometry(new ol.geom.Point(ol.proj.transform([longitude, latitude], projection, map.getView().getProjection()))),
							
							/* fit marker to map */
							map.getView().fit(draggableMarker.getSource().getExtent(), {size: map.getSize()}),
							
							/* apply coordinate to input */
							$(apply_coordinate).val(geojson.writeFeatures(draggableMarker.getSource().getFeatures(), {featureProjection: map.getView().getProjection()}))
						}
						else
						{
							draggableMarker			= new ol.layer.VectorImage
							({
								source: new ol.source.Vector
								({
									features:
									[
										new ol.Feature
										({
											geometry: new ol.geom.Point(ol.proj.transform([longitude, latitude], projection, map.getView().getProjection()))
										})
									]
								}),
								style: new ol.style.Style
								({
									image: new ol.style.Icon
									({
										scale: (icon_scale ? icon_scale : 0.5),
										src: (icon_pattern ? icon_pattern : config.asset_url + 'openlayers/resources/icons/marker.png'),
										anchor: [0.5, 1]
									})
								}),
								zIndex: 100,
								initial: 'draggable'
							});
							
							/* push layer to map */
							map.addLayer(draggableMarker),
							
							/* fit marker to map */
							map.getView().fit(draggableMarker.getSource().getExtent(), {size: map.getSize()}),
							
							/* apply coordinate to input */
							$(apply_coordinate).val(geojson.writeFeatures(draggableMarker.getSource().getFeatures(), {featureProjection: map.getView().getProjection()}));
						}
						
						var drag					= new ol.interaction.Translate
						({
							features: new ol.Collection(draggableMarker.getSource().getFeatures())
						});
						
						/* add drag interaction to marker */
						map.addInteraction(drag),
						
						/* on drag end */
						drag.on('translatestart', function(event)
						{
							popup.hide(),
							
							map.removeOverlay(popup)
						}),
						
						/* on drag end */
						drag.on('translateend', function(event)
						{
							if(typeof event.coordinate !== 'undefined')
							{
								var coordinate		= ol.proj.transform(event.coordinate, map.getView().getProjection(), projection);
								
								$(apply_latitude).val((typeof coordinate[1] !== 'undefined' ? parseFloat(coordinate[1]).toFixed(6) : 0)),
								$(apply_longitude).val((typeof coordinate[0] !== 'undefined' ? parseFloat(coordinate[0]).toFixed(6) : 0)),
								$(apply_coordinate).val(geojson.writeFeatures(event.features.getArray(), {featureProjection: map.getView().getProjection()}))
							}
						});
						
						return;
					}
				})
			}
		},
		
		/**
		 * reset maps
		 */
		reset: function()
		{
			$('.dragPan').remove();
			
			if(map)
			{
				if(drawingManager)
				{
					map.removeInteraction(drawingManager)
				}
				
				if(highlight)
				{
					map.removeInteraction(highlight)
				}
				
				map.getLayers().forEach(function(layer, index)
				{
					if('draggable' == layer.get('initial')) return;
					
					layer.getSource().clear()
				})
			}
			
			if(popup)
			{
				popup.hide()
			}
			
			if(typeof geolocation !== 'undefined')
			{
				/* stop tracking to prevent map flicker */
				geolocation.setTracking(false)
			}
		},
		
		/**
		 * extract given source
		 */
		source: function(source)
		{
			var extension							= source.split('.').pop().toLowerCase();
			
			if('geojson' == extension.replace(/\?.*/, '') || 'json' == extension.replace(/\?.*/, ''))
			{
				openlayers.geojson(source)
			}
			else if('zip' == extension.replace(/\?.*/, '') || 'kmz' == extension.replace(/\?.*/, ''))
			{
				openlayers.unzip(source)
			}
			else if('kml' == extension.replace(/\?.*/, ''))
			{
				openlayers.keyhole(source)
			}
		},
		
		/**
		 * unzip given source
		 */
		unzip: function(source, spinner, ignore_draggable_marker, ignore_fit)
		{
			if(!source) return false;
			
			if(typeof source.initial !== 'undefined' && sessionStorage.getItem(source.initial))
			{
				/* open stored blob */
				openlayers.geojson(sessionStorage.getItem(source.initial), spinner, ignore_draggable_marker, ignore_fit)
			}
			else if(typeof source.url !== 'undefined')
			{
				/**
				 * Read the KMZ / ZIP File from the given source parameter
				 */
				try
				{
					/* read kmz (zip) data */
					JSZipUtils.getBinaryContent(source.url, function(err, data)
					{
						if(err || data.byteLength < 10)
						{
							$('.mdi.mdi-loading.mdi-spin').removeClass('mdi-loading mdi-spin').addClass('mdi-magnify'),
							
							/* archive cannot be extracted, show error */
							console.log(err)
						}
						
						/* unzip archive */
						JSZip.loadAsync(data).then(function(zip)
						{
							/* read extracted datasource */
							Object.keys(zip.files).forEach(function(filename)
							{
								if('geojson' == filename.split('.').pop().toLowerCase() || 'json' == filename.split('.').pop().toLowerCase())
								{
									/* create blob file from extracted data */
									zip.files[filename].async('string').then(function(blob)
									{
										/* write blob file */
										var blobURL	= URL.createObjectURL(new Blob([blob], {type: 'application/json'}));
										
										/* store blob */
										sessionStorage.setItem(source.initial, blobURL),
										
										/* render blob */
										openlayers.geojson(blobURL, spinner, ignore_draggable_marker, ignore_fit)
									})
								}
								else if('kml' == filename.split('.').pop().toLowerCase())
								{
									/* create blob file from extracted data */
									zip.files[filename].async('string').then(function(blob)
									{
										/* write blob file */
										var blobURL	= URL.createObjectURL(new Blob([blob], {type: 'application/vnd.google-earth.kml+xml'}));
										
										/* store blob */
										sessionStorage.setItem(source.initial, blobURL),
										
										/* render blob */
										openlayers.keyhole(blobURL, spinner, ignore_draggable_marker, ignore_fit)
									})
								}
							})
						})
					})
				}
				catch(e)
				{
					console.log(e)
				}
			}
			else if(source.match(/(http(s)?:\/\/.)?(www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/g))
			{
				/**
				 * The source is an url
				 */
				try
				{
					/* read kmz (zip) data */
					JSZipUtils.getBinaryContent(source, function(err, data)
					{
						if(err || data.byteLength < 10)
						{
							$('.mdi.mdi-loading.mdi-spin').removeClass('mdi-loading mdi-spin').addClass('mdi-magnify'),
							
							/* archive cannot be extracted, show error */
							console.log(err)
						}
						
						/* unzip archive */
						JSZip.loadAsync(data).then(function(zip)
						{
							/* read extracted datasource */
							Object.keys(zip.files).forEach(function(filename)
							{
								if('geojson' == filename.split('.').pop().toLowerCase() || 'json' == filename.split('.').pop().toLowerCase())
								{
									/* create blob file from extracted data */
									zip.files[filename].async('string').then(function(blob)
									{
										/* write blob file */
										var blobURL	= URL.createObjectURL(new Blob([blob], {type: 'application/json'}));
										
										openlayers.geojson(blobURL);
										
										return;
									})
								}
								else if('kml' == filename.split('.').pop().toLowerCase())
								{
									/* create blob file from extracted data */
									zip.files[filename].async('string').then(function(blob)
									{
										/* write blob file */
										var blobURL	= URL.createObjectURL(new Blob([blob], {type: 'application/vnd.google-earth.kml+xml'}));
										
										openlayers.keyhole(blobURL);
										
										return;
									})
								}
							})
						})
					})
				}
				catch(e)
				{
					console.log(e)
				}
			}
		},
		
		/**
		 * initialize feature from string
		 */
		geojsonString: function(shapes, type)
		{
			var geojson								= new ol.format.GeoJSON(),
				sourceVector						= new ol.source.Vector
				({
				});
			
			if(typeof shapes.features !== 'undefined')
			{
				var sourceVector					= new ol.source.Vector
				({
					features: geojson.readFeatures
					(
						shapes,
						{
							featureProjection: map.getView().getProjection()
						}
					)
				});
			}
			else if(typeof shapes.geometry !== 'undefined')
			{
				var sourceVector					= new ol.source.Vector
				({
					features: geojson.readFeatures
					(
						{
							type: 'FeatureCollection',
							features: [shapes]
						},
						{
							featureProjection: map.getView().getProjection()
						}
					)
				});
			}
			
			layerVector								= new ol.layer.VectorImage
			({
				source: sourceVector,
				style: function(feature, resolution)
				{
					var pattern						= null,
						icon_width					= 0;
					
					if(icon_pattern || feature.get('icon'))
					{
						var canvas					= document.createElement('canvas');
						var context					= canvas.getContext('2d');
						var image					= new Image();
						
						image.src					= (icon_pattern ? icon_pattern : feature.get('icon'));
						pattern						= context.createPattern(image, 'repeat');
					}
					
					return [new ol.style.Style
					({
						image: new ol.style.Icon
						({
							scale: (icon_scale ? icon_scale : (feature.get('icon-scale') ? feature.get('icon-scale') : 0.5)),
							src: (icon_pattern ? icon_pattern : (feature.get('icon') ? feature.get('icon') : config.asset_url + 'openlayers/resources/icons/marker.png')),
							anchor: [0.5, 1]
						}),
						stroke: new ol.style.Stroke
						({
							color: (stroke_color ? stroke_color : (feature.get('stroke') ? feature.get('stroke') : hex_to_rgba('#ffffff', 0))),
							width: (stroke_width ? stroke_width : (feature.get('stroke-width') ? feature.get('stroke-width') : 2))
						}),
						fill: new ol.style.Fill
						({
							color: (pattern ? pattern : hex_to_rgba((fill_color ? fill_color : feature.get('fill')), (feature.get('fill-opacity') ? feature.get('fill-opacity') : .35)))
						}),
						text: new ol.style.Text
						({
							text: feature.get('title'),
							font: '14px Arial, sans-serif',
							fill: new ol.style.Fill
							({
								color: '#000000'
							}),
							stroke: new ol.style.Stroke
							({
								color: '#ffffff',
								width: 3
							})
						})
					})];
				}
			});
			
			/* push layer to map */
			map.addLayer(layerVector),
			
			/* fit map to features */
			(layerVector.getSource().getFeatures().length ? map.getView().fit(layerVector.getSource().getExtent(), {size: map.getSize()}) : null)
			
			if(type)
			{
				drawingManager						= new ol.interaction.Draw
				({
					type: (type == 'polygon' ? 'Polygon' : (type == 'linestring' ? 'LineString' : 'Point')),
					source: layerVector.getSource()
				});
				drawingType							= type;
				
				/* event on drawing end */
				drawingManager.on('drawend', function(event)
				{
					var drawn						= event.feature,
						features					= layerVector.getSource().getFeatures(),
						coordinate					= ol.proj.transform(drawn.getGeometry().flatCoordinates, map.getView().getProjection(), projection),
						output						= features.concat(drawn),
						measurement					= getMeasurement(output);
						
					$(apply_coordinate).val(geojson.writeFeatures(output, {featureProjection: map.getView().getProjection()})),
					$(apply_latitude).val((typeof coordinate[1] !== 'undefined' ? parseFloat(coordinate[1]).toFixed(6) : 0)),
					$(apply_longitude).val((typeof coordinate[0] !== 'undefined' ? parseFloat(coordinate[0]).toFixed(6) : 0)),
					$(apply_measurement).val((measurement.area > 0 ? measurement.area : measurement.distance))
				});
				
				var drag							= new ol.interaction.Translate
				({
					layers: [layerVector]
				});
				
				var modify							= new ol.interaction.Modify
				({
					source: layerVector.getSource()
				});
				
				var snap							= new ol.interaction.Snap
				({
					source: layerVector.getSource()
				});
				
				var highlight						= new ol.interaction.Select
				({
					layers: [layerVector]
				});
				
				/* add drawing manager */
				map.addInteraction(drawingManager),
				
				/* add feature drag interaction */
				map.addInteraction(drag),
				
				/* add feature modify interaction */
				map.addInteraction(modify),
				
				/* add feature snap interaction */
				map.addInteraction(snap),
				
				/* add feature snap interaction */
				map.addInteraction(highlight),
				
				/* on drag end */
				drag.on('translatestart', function(event)
				{
					popup.hide(),
					
					map.removeOverlay(popup)
				}),
				
				/* on drag end */
				drag.on('translateend', function(event)
				{
					if(typeof event.coordinate !== 'undefined')
					{
						var coordinate				= ol.proj.transform(event.coordinate, map.getView().getProjection(), projection);
						
						$(apply_latitude).val((typeof coordinate[1] !== 'undefined' ? parseFloat(coordinate[1]).toFixed(6) : 0)),
						$(apply_longitude).val((typeof coordinate[0] !== 'undefined' ? parseFloat(coordinate[0]).toFixed(6) : 0))
					}
					
					modify.dispatchEvent
					({
						type: 'modifyend'
					})
				}),
				
				/* on modify end */
				modify.on('modifyend', function(event)
				{
					if(typeof event.target !== 'undefined' && typeof event.target.features_ !== 'undefined')
					{
						event.features				= event.target.features_;
					}
					
					var measurement					= getMeasurement(event.features.getArray()),
						coordinate					= {
							lat: 0,
							lng: 0
						};
					
					event.features.getArray().forEach(function(layer, index)
					{
						coordinate					= ol.proj.transform(layer.getGeometry().flatCoordinates, map.getView().getProjection(), projection);
						coordinate					= {
							lat: coordinate[1],
							lng: coordinate[0]
						};
					}),
					
					$(apply_coordinate).val(geojson.writeFeatures(event.features.getArray(), {featureProjection: map.getView().getProjection()})),
					$(apply_latitude).val(parseFloat(coordinate.lat).toFixed(6)),
					$(apply_longitude).val(parseFloat(coordinate.lng).toFixed(6)),
					$(apply_measurement).val((measurement.area > 0 ? measurement.area : measurement.distance));
					
					if(typeof google !== 'undefined' && 'google' == config.openlayers_search_provider)
					{
						var finder					= new google.maps.Geocoder();
						
						finder.geocode({location: coordinate}, function(response, status)
						{
							if(status === 'OK')
							{
								$(apply_address).val(response[0].formatted_address).trigger('input'),
								$('#gcd-input-query, #autocomplete').val(response[0].formatted_address)
							}
							else
							{
								console.log(status)
							}
						})
					}
					else
					{
						$.get('https://nominatim.openstreetmap.org/reverse?accept-language=id&format=json&lat=' + coordinate.lat + '&lon=' + coordinate.lng + '&addressdetails=1', function(response)
						{
							$(apply_address).val(response.display_name).trigger('input'),
							$('#gcd-input-query, #autocomplete').val(response.display_name)
						})
					}
				}),
				
				highlight.on('select', function(event)
				{
					if(event.selected.length)
					{
						map.addOverlay(popup),
						
						popup.show(event.mapBrowserEvent.coordinate, ('<div class="popup-placeholder"><div class="pt-2 pe-3 pb-2 ps-3 border-bottom"><label class="fw-bold d-block mb-0"><i class="mdi mdi-menu" style="width:30px; display:inline-block"></i> ' + (phrase.options ? phrase.options : 'Options') + '</label></div><div class="popup-content"><div class="list-group list-group-flush"><a href="javascript:void(0)" class="list-group-item list-group-item-action p-3" onclick="removeFeature()"><i class="mdi mdi-trash-can-outline"></i> ' + (phrase.remove_feature ? phrase.remove_feature : 'Remove feature') + '</a></div></div></div>'))
						
						highlighted					= event.selected[0];
					}
					else
					{
						popup.hide(),
						
						map.removeOverlay(popup)
					}
				})
			}
		},
		
		/**
		 * render features from geojson
		 */
		geojson: function(source, spinner, ignore_draggable_marker, ignore_fit, aliases, new_file)
		{
			/* add spinner indicator */
			(spinner ? spinner.removeClass('mdi-magnify').addClass('mdi-loading mdi-spin') : '');
			
			if(layerOverlap && new_file)
			{
				/* remove previously rendered layer vector */
				map.removeLayer(layerOverlap)
			}
			else if(layerVector && !aliases)
			{
				/* remove previously rendered layer vector */
				map.removeLayer(layerVector)
			}
			
			/* initialize layer */
			layerVector								= new ol.layer.VectorImage
			({
				source: new ol.source.Vector
				({
					url: (typeof source.blob !== 'undefined' ? source.blob : (typeof source.url !== 'undefined' ? source.url : source)),
					format: new ol.format.GeoJSON
					({
						extractStyles: true
					}),
					projection: map.getView().getProjection()
				}),
				style: function(feature, resolution)
				{
					var pattern						= null;
					
					if(feature.get('icon'))
					{
						var canvas					= document.createElement('canvas');
						var context					= canvas.getContext('2d');
						var image					= new Image();
						
						image.src					= feature.get('icon');
						pattern						= context.createPattern(image, 'repeat');
					}
					
					if(feature.get('selected'))
					{
						selected.push(feature)
					}
					
					return [new ol.style.Style
					({
						image: new ol.style.Icon
						({
							scale: (icon_scale ? icon_scale : (feature.get('icon-scale') ? feature.get('icon-scale') : 0.5)),
							src: (icon_pattern ? icon_pattern : (feature.get('icon') ? feature.get('icon') : config.asset_url + 'openlayers/resources/icons/marker.png')),
							anchor: [0.5, 1]
						}),
						stroke: new ol.style.Stroke
						({
							color: (stroke_color ? stroke_color : (feature.get('stroke') ? feature.get('stroke') : hex_to_rgba('#ffffff', 0))),
							width: (stroke_width ? stroke_width : (feature.get('stroke-width') ? feature.get('stroke-width') : 2))
						}),
						fill: new ol.style.Fill
						({
							color: (pattern ? pattern : hex_to_rgba(feature.get('fill'), (feature.get('fill-opacity') ? feature.get('fill-opacity') : .35)))
						}),
						text: new ol.style.Text
						({
							text: (feature.get('layer_type') && $.inArray(feature.get('layer_type'), ['polygon', 'linestring']) !== -1 ? feature.get('label') : null),
							font: '14px Arial, sans-serif',
							fill: new ol.style.Fill
							({
								color: '#000000'
							}),
							stroke: new ol.style.Stroke
							({
								color: '#ffffff',
								width: 3
							})
						})
					})];
				},
				initial: (aliases ? 'layerOverlap' : source.initial),
				url: (typeof source.url !== 'undefined' ? source.url : _this.attr('data-finder-url'))
			});
			
			/* push layer to map */
			if(aliases)
			{
				layerOverlap						= layerVector;
				
				map.addLayer(layerOverlap),
				
				/* fit map to features */
				layerOverlap.getSource().once('change', function(e)
				{
					if(layerOverlap.getSource().getState() === 'ready')
					{
						var bounds_selected			= ol.extent.createEmpty(),
							bounds_all				= ol.extent.createEmpty(),
							found_selected			= false,
							found_all				= false;
						
						for(var i = 0; i < layerOverlap.getSource().getFeatures().length; i++)
						{
							if(layerOverlap.getSource().getFeatures()[i].getGeometry())
							{
								if(layerOverlap.getSource().getFeatures()[i].get('selected'))
								{
									found_selected	= true;
									
									ol.extent.extend(bounds_selected, layerOverlap.getSource().getFeatures()[i].getGeometry().getExtent())
								}
								else
								{
									found_all		= true;
									
									ol.extent.extend(bounds_all, layerOverlap.getSource().getFeatures()[i].getGeometry().getExtent())
								}
							}
						}
						
						if(!ignore_fit)
						{
							if(found_selected)
							{
								map.getView().fit(bounds_selected, {size: map.getSize()})
							}
							else if(found_all && !ignore_draggable_marker)
							{
								map.getView().fit(bounds_all, {size: map.getSize()});
								
								if(draggableMarker)
								{
									draggableMarker.getSource().getFeatures()[0].setGeometry(new ol.geom.Point(map.getView().getCenter()))
								}
							}
						}
					}
				});
				
				/* add event listener to remove spinner */
				var listener						= layerOverlap.getSource().once('change', function(e)
				{
					if(layerOverlap.getSource().getState() == 'ready')
					{
						/* remove spinner */
						(spinner ? spinner.removeClass('mdi-loading mdi-spin').addClass('mdi-magnify') : ''),
						
						/* unbind listener */
						ol.Observable.unByKey(listener)
					}
				});
			}
			else
			{
				map.addLayer(layerVector),
				
				/* fit map to features */
				layerVector.getSource().once('change', function(e)
				{
					if(layerVector.getSource().getState() === 'ready')
					{
						var bounds_selected			= ol.extent.createEmpty(),
							bounds_all				= ol.extent.createEmpty(),
							found_selected			= false,
							found_all				= false;
						
						for(var i = 0; i < layerVector.getSource().getFeatures().length; i++)
						{
							if(layerVector.getSource().getFeatures()[i].getGeometry())
							{
								if(layerVector.getSource().getFeatures()[i].get('selected'))
								{
									found_selected	= true;
									
									ol.extent.extend(bounds_selected, layerVector.getSource().getFeatures()[i].getGeometry().getExtent())
								}
								else
								{
									found_all		= true;
									
									ol.extent.extend(bounds_all, layerVector.getSource().getFeatures()[i].getGeometry().getExtent())
								}
							}
						}
						
						if(!ignore_fit)
						{
							if(found_selected)
							{
								map.getView().fit(bounds_selected, {size: map.getSize()})
							}
							else if(found_all && !ignore_draggable_marker)
							{
								map.getView().fit(bounds_all, {size: map.getSize()});
								
								if(draggableMarker)
								{
									draggableMarker.getSource().getFeatures()[0].setGeometry(new ol.geom.Point(map.getView().getCenter()))
								}
							}
						}
					}
				});
				
				/* add event listener to remove spinner */
				var listener						= layerVector.getSource().once('change', function(e)
				{
					if(layerVector.getSource().getState() == 'ready')
					{
						/* remove spinner */
						(spinner ? spinner.removeClass('mdi-loading mdi-spin').addClass('mdi-magnify') : ''),
						
						/* unbind listener */
						ol.Observable.unByKey(listener)
					}
				});
			}
		},
		
		/**
		 * render the keyhole (kml) type of source
		 */
		keyhole: function(source, spinner, ignore_draggable_marker, ignore_fit)
		{
			/* initialize layer */
			layerOverlap							= new ol.layer.VectorImage
			({
				source: new ol.source.Vector
				({
					projection: ol.proj.get(projection),
					url: source,
					format: new ol.format.KML
					({
						extractStyles: true
					})
				}),
				type: 'xml',
				initial: 'layerOverlap'
			});
			
			/* push layer to map */
			map.addLayer(layerOverlap),
			
			/* fit map to features */
			layerOverlap.getSource().once('change',function(e)
			{
				if(layerOverlap.getSource().getState() === 'ready')
				{
					if(layerOverlap.getSource().getExtent().length && $.inArray(Infinity, layerOverlap.getSource().getExtent()) === -1)
					{
						map.getView().fit(layerOverlap.getSource().getExtent(), {size: map.getSize()})
					}
				}
			})
		},
		
		/**
		 * render the features from ArcGIS Rest API
		 */
		rest: function(source)
		{
			var esriJSON							= new ol.format.EsriJSON();
			
			var vectorSource						= new ol.source.Vector
			({
				loader: function(extent, resolution, projection)
				{
					$.ajax
					({
						url: source + '/query',
						data:
						{
							f: 'json',
							returnGeometry: true,
							spatialRel: 'esriSpatialRelIntersects',
							geometry: '{"xmin":' + extent[0] + ',"ymin":' + extent[1] + ',"xmax":' + extent[2] + ',"ymax":' + extent[3] + '}',
							geometryType: 'esriGeometryEnvelope',
							inSR: 102100,
							outFields:'*',
							outSR: 102100
						},
						dataType: 'jsonp',
						success: function(response)
						{
							if(response.error)
							{
								console.log(response.error.message, response.error.details.join('\n'))
							}
							else
							{
								var features			= esriJSON.readFeatures(response, {featureProjection: projection});
								
								if (features.length > 0)
								{
									vectorSource.addFeatures(features)
								}
							}
						}
					})
				},
				strategy: ol.loadingstrategy.tile(ol.tilegrid.createXYZ
				({
					tileSize: 512
				}))
			});
			
			layerOverlap							= new ol.layer.VectorImage
			({
				source: vectorSource
			}),
			
			/* push layer to map */
			map.addLayer(layerOverlap),
			
			/* fit map to features */
			layerOverlap.getSource().once('change',function(e)
			{
				if(layerOverlap.getSource().getState() === 'ready')
				{
					if(layerOverlap.getSource().getExtent().length && $.inArray(Infinity, layerOverlap.getSource().getExtent()) === -1)
					{
						map.getView().fit(layerOverlap.getSource().getExtent(), {size: map.getSize()})
					}
				}
			})
		},
		
		/**
		 * render the features from ArcGIS Rest API
		 */
		wms: function(source)
		{
			layerOverlap							= new ol.layer.Tile
			({
				source: new ol.source.TileArcGISRest
				({
					url: source,
					projection: map.getView().getProjection()
				})
			});
			
			/* push layer to map */
			map.addLayer(layerOverlap),
			
			/* fit map to features */
			layerOverlap.getSource().once('change',function(e)
			{
				if(layerOverlap.getSource().getState() === 'ready')
				{
					if(layerOverlap.getSource().getExtent().length && $.inArray(Infinity, layerOverlap.getSource().getExtent()) === -1)
					{
						map.getView().fit(layerOverlap.getSource().getExtent(), {size: map.getSize()})
					}
				}
			})
		},
		
		/**
		 * create editable marker
		 */
		coordinate: function(draggable)
		{
			draggableMarker							= new ol.layer.VectorImage
			({
				source: new ol.source.Vector
				({
					features:
					[
						new ol.Feature
						({
							type: 'click',
							title: '<label class="d-block fw-bold text-muted mb-0">' + (phrase.default_marker ? phrase.default_marker : 'Default Marker') + '</label>',
							description: '<p class="mb-0">' + (phrase.this_can_be_drag_on_edit_mode ? phrase.this_can_be_drag_on_edit_mode : 'This can be drag on edit mode') + '</p>',
							geometry: new ol.geom.Point(map.getView().getCenter())
						})
					]
				}),
				style: new ol.style.Style
				({
					image: new ol.style.Icon
					({
						src: config.asset_url + 'openlayers/resources/icons/marker.png',
						anchor: [0.5, 1]
					})
				}),
				zIndex: 100,
				initial: 'draggable'
			});
			
			/* push layer to map */
			map.addLayer(draggableMarker);
			
			if(draggable)
			{
				var drag							= new ol.interaction.Translate
				({
					features: new ol.Collection(draggableMarker.getSource().getFeatures())
				});
				
				/* add drag interaction to marker */
				map.addInteraction(drag),
					
				/* event on marker drag end */
				drag.on('translateend', function(event)
				{
					/* dragend event */
					if(typeof geolocation !== 'undefined')
					{
						geolocation.setTracking(false)
					}
					
					var coordinate					= ol.proj.transform(event.coordinate, map.getView().getProjection(), projection);
					
					var coordinate					=
					{
						lat: coordinate[1],
						lng: coordinate[0]
					};
					
					$(apply_latitude).val(parseFloat(coordinate.lat).toFixed(6)),
					$(apply_longitude).val(parseFloat(coordinate.lng).toFixed(6)),
					$(apply_coordinate).val(JSON.stringify(coordinate));
					
					if(typeof google !== 'undefined' && 'google' == config.openlayers_search_provider)
					{
						var finder					= new google.maps.Geocoder();
						
						finder.geocode({location: coordinate}, function(response, status)
						{
							if(status === 'OK')
							{
								$(apply_address).val(response[0].formatted_address).trigger('input'),
								$('#gcd-input-query, #autocomplete').val(response[0].formatted_address)
							}
							else
							{
								console.log(status)
							}
						})
					}
					else
					{
						/* getting the address name */
						$.get('https://nominatim.openstreetmap.org/reverse?accept-language=id&format=json&lat=' + coordinate.lat + '&lon=' + coordinate.lng + '&addressdetails=1', function(response)
						{
							if(typeof response !== 'undefined')
							{
								/* apply to inputs */
								$(apply_address).val(response.display_name).trigger('input'),
								$('#gcd-input-query, #autocomplete').val(response.display_name)
							}
						})
					}
				})
			}
		},
		
		/**
		 * add geocoder (place search)
		 */
		geocoder: function(_this)
		{
			geocoder								= new Geocoder
			(
				'nominatim',
				{
					provider: ('openlayers' == config.openlayers_search_provider ? 'osm' : config.openlayers_search_provider), /* available provider: osm, mapquest (require key), photon, pelias(require key), bing(require key) and opencage(require key) */
					key: config.openlayers_search_key, /* api key */
					targetType: 'text-input',
					countrycodes: 'id',
					placeholder: (phrase.search_place ? phrase.search_place : 'Search Place'),
					limit: 10,
					autoComplete: true,
					featureStyle: null
				}
			);
			
			/* add geocoder into map controls directories */
			map.addControl(geocoder);
			
			if(typeof google !== 'undefined' && 'google' == config.openlayers_search_provider)
			{
				var autocomplete					= new google.maps.places.Autocomplete
				(
					(document.getElementById('gcd-input-query')),
					{
						componentRestrictions:
						{
							country: 'id'
						},
						fields: ['formatted_address', 'geometry', 'name'],
						strictBounds: false,
						types: ['establishment']
					}
				);
				
				google.maps.event.addListener(autocomplete, 'place_changed', function()
				{
					var place						= autocomplete.getPlace();
					
					if(typeof place.geometry === 'undefined')
					{
						return;
					}
					
					if(typeof geolocation !== 'undefined')
					{
						geolocation.setTracking(false)
					}
					
					if(!drawingType)
					{
						/* apply to inputs */
						$(apply_coordinate).val(JSON.stringify({lat: place.geometry.location.lat(), lng: place.geometry.location.lng()}))
					}
					
					$(apply_latitude).val(place.geometry.location.lat()),
					$(apply_longitude).val(place.geometry.location.lng()),
					$(apply_address).val(place.formatted_address).trigger('input'),
					
					map.getView().setCenter(ol.proj.transform([place.geometry.location.lng(), place.geometry.location.lat()], projection, map.getView().getProjection()));
					
					if(draggableMarker)
					{
						draggableMarker.getSource().getFeatures()[0].setGeometry(new ol.geom.Point(ol.proj.transform([place.geometry.location.lng(), place.geometry.location.lat()], projection, map.getView().getProjection()))),
					
						map.getView().fit(draggableMarker.getSource().getExtent(), {size: map.getSize()})
					}
					
					if(_this.attr('data-finder-url'))
					{
						xhr							= $.ajax
						({
							url: _this.attr('data-finder-url'),
							method: 'POST',
							data:
							{
								lat: place.geometry.location.lat(),
								lng: place.geometry.location.lng()
							},
							beforeSend: function()
							{
								if(xhr)
								{
									xhr.abort()
								}
							}
						})
						.done(function(response)
						{
							if(typeof response.url !== 'undefined')
							{
								openlayers.unzip(response, null, true)
							}
						})
					}
				})
			}
			else
			{
				/* create event when address is chosen */
				geocoder.on('addresschosen', function(response)
				{
					if(typeof geolocation !== 'undefined')
					{
						geolocation.setTracking(false)
					}
					
					var coordinate					= ol.proj.transform(response.coordinate, map.getView().getProjection(), projection);
					var coordinate					=
					{
						lat: coordinate[1],
						lng: coordinate[0]
					};
					
					if(!drawingType)
					{
						/* apply to inputs */
						$(apply_coordinate).val(JSON.stringify(coordinate))
					}
					
					$(apply_latitude).val(coordinate.lat),
					$(apply_longitude).val(coordinate.lng),
					$(apply_address).val(response.address.details.name).trigger('input'),
					
					$('#gcd-input-query').val(response.address.details.name),
					
					map.getView().setCenter(response.coordinate);
					
					if(draggableMarker)
					{
						draggableMarker.getSource().getFeatures()[0].setGeometry(new ol.geom.Point(response.coordinate)),
					
						map.getView().fit(draggableMarker.getSource().getExtent(), {size: map.getSize()})
					}
					
					if(_this.attr('data-finder-url'))
					{
						xhr							= $.ajax
						({
							url: _this.attr('data-finder-url'),
							method: 'POST',
							data:
							{
								lat: coordinate.lat,
								lng: coordinate.lng
							},
							beforeSend: function()
							{
								if(xhr)
								{
									xhr.abort()
								}
							}
						})
						.done(function(response)
						{
							if(typeof response.url !== 'undefined')
							{
								openlayers.unzip(response, null, true)
							}
						})
					}
				})
			}
		},
		
		/**
		 * add geolocation (user based location)
		 */
		geolocation: function()
		{
			if(navigator.geolocation)
			{
				geolocation							= new ol.Geolocation
				({
					projection: map.getView().getProjection(),
					tracking: true,
					trackingOptions:
					{
						enableHighAccuracy: true,
						maximumAge: 2000
					}
				});
				
				/* on device position change */
				geolocation.on('change', function()
				{
					if(apply_route_to.length && !apply_route_from.length)
					{
						/* stop tracking to prevent map flicker */
						geolocation.setTracking(false),
						
						openlayers.route(ol.proj.transform(geolocation.getPosition(), map.getView().getProjection(), projection).reverse(), apply_route_to, 'driving');
					}
					else
					{
						map.getView().setCenter(geolocation.getPosition())
						
						if(draggableMarker)
						{
							draggableMarker.getSource().getFeatures()[0].setGeometry(new ol.geom.Point(geolocation.getPosition())),
						
							map.getView().fit(draggableMarker.getSource().getExtent(), {size: map.getSize()});
							
							if(!drawingType)
							{
								var coordinate		= ol.proj.transform(geolocation.getPosition(), map.getView().getProjection(), projection);
								var coordinate		=
								{
									lat: coordinate[1],
									lng: coordinate[0]
								};
								
								/* apply to inputs */
								$(apply_coordinate).val(JSON.stringify(coordinate))
							}
						}
					}
					
				});
				
				var handleTrack						= function(e)
				{
					map.getView().setCenter(geolocation.getPosition());
					
					if(draggableMarker)
					{
						draggableMarker.getSource().getFeatures()[0].setGeometry(new ol.geom.Point(geolocation.getPosition())),
					
						map.getView().fit(draggableMarker.getSource().getExtent(), {size: map.getSize()});
						
						if(!drawingType)
						{
							var coordinate			= ol.proj.transform(geolocation.getPosition(), map.getView().getProjection(), projection);
							var coordinate			=
							{
								lat: coordinate[1],
								lng: coordinate[0]
							};
							
							/* apply to inputs */
							$(apply_coordinate).val(JSON.stringify(coordinate))
						}
					}
				};
				
				var icon							= document.createElement('i');
				var button							= document.createElement('button');
				var element							= document.createElement('div');
				
				icon.setAttribute('class', 'mdi mdi-crosshairs-gps'),
				button.setAttribute('title', (phrase.track_me ? phrase.track_me : 'Track Me')),
				button.setAttribute('type', 'button'),
				button.appendChild(icon),
				button.addEventListener('click', handleTrack, false),
				element.setAttribute('class', 'ol-track ol-unselectable ol-control'),
				element.appendChild(button),
				
				map.addControl
				(
					new ol.control.Control
					({
						element: element
					})
				)
			};
		},
		
		/**
		 * routing machine
		 */
		route: function(starting_point, destination, type)
		{
			if(!starting_point || !destination)
			{
				alert('Please choose the starting point and destination!');
				
				return;
			}
			
			if(routeWayPoints)
			{
				routeWayPoints.getSource().clear()
			}
			
			if(routeLineString)
			{
				routeLineString.getSource().clear()
			}
			
			routeWayPoints							= new ol.layer.VectorImage
			({
				source: new ol.source.Vector(),
				style: new ol.style.Style
				({
					image: new ol.style.Icon
					({
						src: config.asset_url + 'openlayers/resources/icons/marker.png',
						anchor: [0.5, 1]
					})
				}),
				zIndex: 100
			});
			
			routeLineString							= new ol.layer.VectorImage
			({
				source: new ol.source.Vector(),
				style: new ol.style.Style
				({
					stroke: new ol.style.Stroke
					({
						width: 5,
						color: [40, 40, 255, 0.8]
					})
				}),
				zIndex: 100
			});
			
			if(typeof google !== 'undefined' && 'google' == config.openlayers_search_provider)
			{
				var routing							= new google.maps.DirectionsService();
				
				routing.route({origin: ($.isArray(starting_point) ? starting_point.join() : starting_point), destination: ($.isArray(destination) ? destination.join() : destination), travelMode: (type == 'cycling' ? 'BICYCLING' : (type == 'walking' ? 'WALKING' : 'DRIVING'))}, function(response, status)
				{
					if(status != 'OK')
					{
						return;
					}
					
					$.each(response.routes[0].legs, function(key, val)
					{
						$.each(val.steps, function(_key, _val)
						{
							/* push route to map */
							routeLineString.getSource().addFeature
							(
								new ol.Feature
								({
									type: 'route',
									geometry: new ol.format.Polyline().readGeometry(_val.polyline.points, {dataProjection: projection, featureProjection: map.getView().getProjection()})
								})
							)
						})
					})
				})
			}
			else
			{
				if(!$.isArray(starting_point))
				{
					starting_point					= starting_point.split(',').reverse().join();
				}
				
				if(!$.isArray(destination))
				{
					destination						= destination.split(',').reverse().join();
				}
				
				$.get('//router.project-osrm.org/route/v1/' + (type ? type : 'driving') + '/' + starting_point + ';' + destination, {overview: 'full', alternatives: true, steps: (type == 'walking' ? true : false)}, function(response)
				{
					if(typeof response.code === 'undefined' || response.code != 'Ok')
					{
						return;
					}
					
					$.each(response.routes, function(key, val)
					{
						/* push route to map */
						routeLineString.getSource().addFeature
						(
							new ol.Feature
							({
								type: 'route',
								geometry: new ol.format.Polyline().readGeometry(val.geometry, {dataProjection: projection, featureProjection: map.getView().getProjection()})
							})
						)
					})
				})
			}
			
			if(!$.isArray(starting_point))
			{
				starting_point						= starting_point.split(',');
			}
			
			if(!$.isArray(destination))
			{
				destination							= destination.split(',');
			}
			
			/* add point between route to map */
			routeWayPoints.getSource().addFeature
			(
				new ol.Feature
				({
					geometry: new ol.geom.Point(ol.proj.fromLonLat((typeof google !== 'undefined' && 'google' == config.openlayers_search_provider ? starting_point.reverse() : starting_point)))
				})
			),
			routeWayPoints.getSource().addFeature
			(
				new ol.Feature
				({
					geometry: new ol.geom.Point(ol.proj.fromLonLat((typeof google !== 'undefined' && 'google' == config.openlayers_search_provider ? destination.reverse() : destination)))
				})
			),
			
			/* push route and waypoints to map */
			map.addLayer(routeLineString),
			map.addLayer(routeWayPoints),
			
			/* fit route to extent */
			(routeWayPoints.getSource().getFeatures().length ? map.getView().fit(routeWayPoints.getSource().getExtent(), {size: map.getSize()}) : null)
		},
		
		/**
		 * selection
		 */
		selection: function(appendTo)
		{
			selected								= highlight.getFeatures();
			selectionBox							= new ol.interaction.DragBox
			({
				condition: ol.events.condition.platformModifierKeyOnly
			});
			
			map.addInteraction(selectionBox),
			
			selectionBox.on('boxend', function(e)
			{
				var extent							= selectionBox.getGeometry().getExtent(),
					resolution						= map.getView().getResolution(),
					exists							= [];
				
				map.getLayers().getArray().forEach(function(layer, index)
				{
					if(!index) return;
					
					layer.getSource().forEachFeatureIntersectingExtent(extent, function(feature)
					{
						if(!feature.get('object_id'))
						{
							return;
						}
						
						var group					= feature.get('group_id');
						
						if(typeof exists[group] !== 'undefined')
						{
							exists[group]++;
						}
						else
						{
							exists[group]			= 1;
						}
						
						selected.push(feature);
					})
				}),
				
				map.getView().fit(extent, {size: map.getSize()}),
				
				map.getView().setResolution(resolution),
				
				$.each(exists, function(key, val)
				{
					if(val)
					{
						$(appendTo).find('[data-initial=' + key + ']').find('.badge').addClass('bg-info').text(val.toLocaleString('en'));
						$(appendTo).find('[data-initial=' + key + ']').find('input[type=checkbox]').prop('checked', true),
						$(appendTo).find('[data-initial=' + key + ']').find('label').removeClass('text-muted')
					}
				})
			}),
			
			selectionBox.on('boxstart', function(e)
			{
				selected.clear(),
				$(appendTo).find('.badge').text(''),
				$(appendTo).find('input[type=checkbox]').prop('checked', false),
				$(appendTo).find('label').addClass('text-muted')
			}),
			
			map.on('click', function()
			{
				selected.clear(),
				$(appendTo).find('.badge').text(''),
				$(appendTo).find('input[type=checkbox]').prop('checked', false),
				$(appendTo).find('label').addClass('text-muted')
			})
		},
		
		/**
		 * identification
		 */
		identification: function(appendTo)
		{
			selected								= highlight.getFeatures();
			selectionBox							= new ol.interaction.DragBox
			({
				condition: ol.events.condition.platformModifierKeyOnly
			});
			
			map.addInteraction(selectionBox),
			
			selectionBox.on('boxend', function(e)
			{
				var info							= [],
					extent							= selectionBox.getGeometry().getExtent(),
					resolution						= map.getView().getResolution(),
					exist							= [],
					num								= 0;
				
				$(appendTo).html(''),
				
				map.getLayers().getArray().forEach(function(layer, index)
				{
					if(!index) return;
					
					layer.getSource().forEachFeatureIntersectingExtent(extent, function(feature)
					{
						if(!feature.get('object_id'))
						{
							return;
						}
						
						if(typeof feature.get('object_id') !== 'undefined')
						{
							var object_id			= feature.get('object_id');
						}
						else
						{
							/* get primary id from description that contain object_id attribute */
							var object_id			= feature.get('description').toLowerCase() + ' ',
								object_id			= object_id.replace(/(<b[^>]+?>|<b>|<\/b>)/ig, ' '),
								object_id			= object_id.replace(/\s\s+/g, ' '),
								object_id			= object_id.substring(object_id.lastIndexOf('object_id = ') + 11),
								object_id			= object_id.substr(0, object_id.indexOf(' '));
						}
						
						feature.setId(object_id),
						
						selected.push(feature);
					
						if($.inArray(object_id, exist) === -1)
						{
							exist.push(object_id),
							
							$('<div class="identification-item pt-2 pb-2' + ($('.identification-information').children().length > 0 ? ' border-top' : '') + '" data-title="' + feature.get('title') + '" data-url="' + layer.get('url') + '" data-target="' + object_id + '" style="cursor:pointer">' + (feature.get('label') ? feature.get('label') : feature.get('title')) + '</div>').appendTo(appendTo)
						}
					}),
					
					$('body').off('mouseover.identification-item'),
					$('body').on('mouseover.identification-item', '.identification-item', function(e)
					{
						if(layer.getSource().getFeatureById($(this).attr('data-target')))
						{
							map.getView().setCenter(ol.extent.getCenter(layer.getSource().getFeatureById($(this).attr('data-target')).getGeometry().getExtent()), {size: map.getSize()}),
							
							popup.show(layer.getSource().getFeatureById($(this).attr('data-target')).getGeometry().getExtent(), ('<div class="popup-placeholder"><div class="popup-content"><label class="d-block text-muted text-center pt-3 pb-3">' + (phrase.click_to_get_detail ? phrase.click_to_get_detail : 'Click to get detail') + '</label></div></div>'))
						}
					}),
					
					$('body').off('mouseout.identification-item'),
					$('body').on('mouseout.identification-item', '.identification-item', function(e)
					{
						popup.hide()
					}),
					
					$('body').off('click.identification-item touch.identification-item'),
					$('body').on('click.identification-item touch.identification-item', '.identification-item', function(e)
					{
						if(layer.getSource().getFeatureById($(this).attr('data-target')))
						{
							map.getView().setCenter(ol.extent.getCenter(layer.getSource().getFeatureById($(this).attr('data-target')).getGeometry().getExtent()), {size: map.getSize()}),
							
							$.ajax
							({
								url: _this.attr('data-finder-url'),
								method: 'POST',
								data:
								{
									objectID: $(this).attr('data-target')
								},
								beforeSend: function()
								{
									$('.popup-content').html('<div class="d-flex justify-content-center p-3"><div class="spinner-border spinner-border-sm" role="status"><span class="visually-hidden">' + (phrase.loading ? phrase.loading : 'Loading...') + '</span></div></div>')
								}
							})
							.done(function(response)
							{
								$('.popup-title').html(response.title),
								$('.popup-content').html(response.content)
							})
						}
					})
				}),
				
				map.getView().fit(extent, {size: map.getSize()})
			}),
			
			selectionBox.on('boxstart', function(e)
			{
				selected.clear()
			}),
			
			map.on('click', function()
			{
				$(appendTo).html(''),
				selected.clear()
			})
		},
		
		/**
		 * measurement
		 */
		measurement: function(type, appendTo)
		{
			$(appendTo).html('');
			
			if(typeof map !== 'undefined' && typeof drawingManager !== 'undefined')
			{
				map.removeInteraction(drawingManager);
				
				drawingManager						= null;
			}
			
			if(measurementVector)
			{
				measurementVector.getSource().clear()
			}
			
			if(type == 'area' || type == 'distance')
			{
				measurementVector					= new ol.layer.VectorImage
				({
					source: new ol.source.Vector(),
					style: new ol.style.Style
					({
						stroke: new ol.style.Stroke
						({
							color: colorscheme,
							width: 3
						}),
						fill: new ol.style.Fill
						({
							color: hex_to_rgba(colorscheme, .15)
						})
					})
				});
				
				drawingManager						= new ol.interaction.Draw
				({
					type: ('area' == type ? 'Polygon' : 'LineString'),
					source: measurementVector.getSource()
				});
				
				/* push layer to map */
				map.addLayer(measurementVector),
				
				/* create drawing tools */
				map.addInteraction(drawingManager),
				
				/* event on drawing end */
				drawingManager.on('drawstart', function(event)
				{
					clicked							= true;
					
					measurementVector.getSource().clear()
				}),
				
				/* event on drawing end */
				drawingManager.on('drawend', function(event)
				{
					clicked							= false;
					
					var key							= (features.length ? parseInt(features.length + 1) : 0),
						prepare						= [];
					
					features[key]					= event.feature.getGeometry().getCoordinates();
					
					$.each(features, function(_key, _val)
					{
						if(!_val) return;
						
						var coord					= [],
							_val					= ('area' == type ? _val[0] : _val);
						$.each(_val, function(__key, __val)
						{
							coord.push(ol.proj.transform(__val, map.getView().getProjection(), projection))
						}),
						prepare.push
						({
							type: 'Feature',
							geometry:
							{
								type: ('area' == type ? 'Polygon' : 'LineString'),
								coordinates: ('area' == type ? [coord] : coord)
							},
							properties:
							{
							}
						})
					});
					
					var meter						= (Math.round('area' == type ? event.feature.getGeometry().getArea() : event.feature.getGeometry().getLength())),
						value						= $(appendTo).prev('.form-group').find('select').val(),
						label						= $(appendTo).prev('.form-group').find('select option:selected').html(),
						result						= ('area' == type ? ('ac' == value ? meter / 4047 : ('mi' == value ? meter / 2.59e+6 : ('ha' == value ? meter / 10000 : ('yd' == value ? meter / 1.196 : ('ft' == value ? meter / 10.764 : ('km' == value ? meter / 1000 : meter)))))) : ('mi' == value ? meter / 1609 : ('yd' == value ? meter / 1.094 : ('ft' == value ? meter / 10.764 : ('km' == value ? meter / 1000 : meter)))));
						
					$(appendTo).html
					(
						'<div class="text-center mt-3">' +
							'<h6>' +
								(phrase.measurement_result ? phrase.measurement_result : 'Measurement result') +
							'</h6>' +
							'<h3>' +
								result.toLocaleString('en') +
							'</h3>' +
							'<h3>' +
								label +
							'</h3>' +
						'</div>'
					)
				})
			}
			else
			{
				map.on('singleclick', function(event)
				{
					var coordinate					= ol.proj.transform(event.coordinate, map.getView().getProjection(), projection),
						hdms						= ol.coordinate.toStringHDMS(coordinate, 4);
					
					if(measurementVector)
					{
						measurementVector.getSource().clear()
					}
					
					measurementVector				= new ol.layer.VectorImage
					({
						source: new ol.source.Vector
						({
							features:
							[
								new ol.Feature
								({
									geometry: new ol.geom.Point(ol.proj.fromLonLat([coordinate[0], coordinate[1]]))
								})
							]
						}),
						style: new ol.style.Style
						({
							image: new ol.style.Icon
							({
								src: config.asset_url + 'openlayers/resources/icons/marker.png',
								anchor: [0.5, 1]
							})
						})
					});
					
					/* push layer to map */
					map.addLayer(measurementVector)
					
					$(appendTo).html
					(
						'<div class="text-center mt-3">' +
							'<h6 class="mb-3">' +
								(phrase.measurement_result ? phrase.measurement_result : 'Measurement result') +
							'</h6>' +
							'<div class="row">' +
								'<div class="col-6 fw-bold">' +
									(phrase.latitude ? phrase.latitude : 'Latitude') +
								'</div>' +
								'<div class="col-6 fw-bold">' +
									(phrase.longitude ? phrase.longitude : 'Longitude') +
								'</div>' +
							'</div>' +
							'<div class="row mb-3">' +
								'<div class="col-6">' +
									coordinate[1].toFixed(6) +
								'</div>' +
								'<div class="col-6">' +
									coordinate[0].toFixed(6) +
								'</div>' +
							'</div>' +
							'<div class="mb-3">' +
								'<label class="d-block fw-bold">HDMS</label>' +
								'<p>' +
									hdms +
								'</p>' +
							'</div>' +
						'</div>'
					)
				})
			}
		},
		
		/**
		 * upload
		 */
		upload: function(data)
		{
			if('zip' !== data.name.split('.').pop().toLowerCase() && 'kmz' !== data.name.split('.').pop().toLowerCase())
			{
				alert('Only KMZ or ZIP file are allowed to upload!');
				
				return;
			}
			
			if(map && layerOverlap)
			{
				map.removeLayer(layerOverlap)
			}
			
			try
			{
				/* unzip archive */
				JSZip.loadAsync(data).then(function(zip)
				{
					var new_file					= true;
					
					/* read extracted datasource */
					Object.keys(zip.files).forEach(function(filename)
					{
						if('geojson' == filename.split('.').pop().toLowerCase() || 'json' == filename.split('.').pop().toLowerCase())
						{
							/* create blob file from extracted data */
							zip.files[filename].async('string').then(function(blob)
							{
								/* write blob file */
								var blobURL			= URL.createObjectURL(new Blob([blob], {type: 'application/json'}));
								
								openlayers.geojson(blobURL, null, null, null, true, (new_file ? true : false));
								
								new_file			= false;
							})
						}
						else if('kml' == filename.split('.').pop().toLowerCase())
						{
							/* create blob file from extracted data */
							zip.files[filename].async('string').then(function(blob)
							{
								/* write blob file */
								var blobURL			= URL.createObjectURL(new Blob([blob], {type: 'application/vnd.google-earth.kml+xml'}));
								
								openlayers.keyhole(blobURL)
							})
						}
					})
				})
			}
			catch(e)
			{
				alert('Unsupported geospatial format!')
			}
		},
		
		/**
		 * download
		 */
		download: function(type, size, resolution)
		{
			if('png' == type)
			{
				//map.once('rendercomplete', function()
				//{
					var canvas						= $('.ol-layer canvas');
					
					if(canvas && typeof canvas[0] !== 'undefined')
					{
						if(navigator.msSaveBlob)
						{
							navigator.msSaveBlob(canvas[0].msToBlob(), 'map.png')
						}
						else
						{
							var link				= document.getElementById('image-download');
							link.href				= canvas[0].toDataURL();
							
							link.click()
						}
					}
				//})
			}
			else if('pdf' == type)
			{
				//map.once('rendercomplete', function()
				//{
					var canvas						= $('.ol-layer canvas');
					
					if(canvas && typeof canvas[0] !== 'undefined')
					{
						require.js([config.asset_url + 'jspdf/jspdf.min.js'], function()
						{
							var resolution			= ($.inArray(resolution, ['a0', 'a1', 'a2', 'a3', 'a4', 'a5']) !== -1 ? resolution : 'a4'),
								doc					= new jsPDF('l', 'mm', resolution);
							
							doc.addImage(canvas[0].toDataURL(), 'PNG', 0, 0, doc.internal.pageSize.getWidth(), doc.internal.pageSize.getHeight())
							doc.save('map.pdf')
						})
					}
				//})
			}
		}
	}
})();

function getMeasurement(features)
{
	var area										= 0,
		distance									= 0;
	
	features.forEach(function(feature)
	{
		var geometry								= feature.getGeometry();
			
		if(geometry instanceof ol.geom.Polygon)
		{
			area									+= (Math.round(geometry.getArea() * 100) / 100);
			distance								+= (Math.round((new ol.geom.LineString(geometry.getLinearRing(0).getCoordinates())).getLength() * 100) / 100);
		}
		else if(geometry instanceof ol.geom.LineString)
		{
			distance								+= (Math.round(geometry.getLength() * 100) / 100);
		}
	});
	
	return {
		area: area.toFixed(2),
		distance: distance.toFixed(2)
	};
}

function removeFeature()
{
	layerVector.getSource().removeFeature(highlighted);
	
	var geojson										= new ol.format.GeoJSON(),
		measurement									= getMeasurement(layerVector.getSource().getFeatures());
	
	$(apply_coordinate).val(geojson.writeFeatures(layerVector.getSource().getFeatures(), {featureProjection: map.getView().getProjection()})),
	
	$(apply_measurement).val((measurement.area > 0 ? measurement.area : measurement.distance)),
	
	popup.hide(),
	
	map.removeOverlay(popup)
}